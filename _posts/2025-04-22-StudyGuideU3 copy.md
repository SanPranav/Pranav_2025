---
layout: post 
search_exclude: true
show_reading_time: false
permalink: /StudyG3
title: Pranav's Study Guide - Unit 3
categories: [Pranav Study Guide]
---
{% include nav/study.html %}
# AP Computer Science Principles (CSP) Study Guide - Unit 3

## BIG IDEA 3: ALGORITHMS AND PROGRAMMING

### 3.1 Variables and Assignments
- **Variable Types**: Numeric, string, boolean
- **Assignment Operations**: Setting and changing variable values
- **Constants**: Variables that don't change
- **Naming Conventions**: Readable and meaningful names
- **Scope**: Global vs. local variables

### 3.2 Data Structures
- **Lists/Arrays**: Ordered collections of items
- **Dictionaries/Maps**: Key-value pairs
- **Sets**: Unordered collections with no duplicates
- **Objects**: Custom data structures
- **Nested Structures**: Lists of lists, etc.

### 3.3 Mathematical Expressions
- **Arithmetic Operators**: +, -, *, /, %
- **Assignment Operators**: =, +=, -=, etc.
- **Order of Operations**: PEMDAS in programming
- **Rounding and Truncation**: Managing decimal places
- **Mathematical Libraries**: Using math functions

### 3.4 Strings
- **String Operations**: Concatenation, substring, etc.
- **String Methods**: Length, find, replace, etc.
- **String Formatting**: Creating formatted output
- **Character Access**: Indexing into strings
- **String Immutability**: Understanding string behavior

### 3.5 Boolean Expressions
- **Logical Operators**: AND, OR, NOT
- **Comparison Operators**: ==, !=, <, >, <=, >=
- **Truth Tables**: Understanding logic combinations
- **Short-Circuit Evaluation**: How boolean expressions are processed
- **DeMorgan's Laws**: Transforming boolean expressions

### 3.6 Conditionals
- **If Statements**: Single path selection
- **If-Else**: Two-path selection
- **If-Elif-Else**: Multi-path selection
- **Nested Conditionals**: Conditions within conditions
- **Switch/Case Statements**: Alternative to multiple if statements

### 3.7 Nested Conditionals
- **Structure**: Organization of nested if statements
- **Complexity Management**: Keeping code readable
- **Boolean Algebra**: Simplifying nested conditions
- **Approaches to Nesting**: Different styles and practices
- **Complex Decision Trees**: Building decision-making logic

### 3.8 Iteration
- **For Loops**: Iterating a specific number of times
- **While Loops**: Iterating based on a condition
- **Nested Loops**: Loops within loops
- **Loop Control**: Break and continue statements
- **Infinite Loops**: Causes and prevention

### 3.9 Developing Algorithms
- **Algorithm Definition**: Step-by-step problem solutions
- **Algorithm Design**: Planning before coding
- **Pseudocode**: Writing human-readable algorithm descriptions
- **Flowcharts**: Visual representations of algorithms
- **Algorithm Analysis**: Efficiency and effectiveness

### 3.10 Lists
- **List Creation**: Making and initializing lists
- **List Operations**: Accessing, adding, removing elements
- **List Methods**: Common list manipulation techniques
- **List Traversal**: Iterating through lists
- **2D Lists**: Working with grid-like data

### 3.11 Binary Search
- **Algorithm**: How binary search works
- **Requirements**: Sorted data
- **Implementation**: Writing binary search code
- **Time Complexity**: O(log n) efficiency
- **Applications**: When to use binary search

### 3.12 Calling Procedures
- **Procedure Definition**: Creating reusable code blocks
- **Parameters**: Passing data to procedures
- **Return Values**: Getting data from procedures
- **Procedure Calls**: Invoking procedures in code
- **Stack Frames**: Understanding procedure execution

### 3.13 Developing Procedures
- **Procedural Abstraction**: Breaking code into modules
- **Parameters and Return Types**: Designing procedure interfaces
- **Documentation**: Writing clear procedure descriptions
- **Testing Procedures**: Validating correct behavior
- **Procedure Libraries**: Building reusable components

### 3.14 Libraries
- **Standard Libraries**: Built-in language functionality
- **Third-Party Libraries**: External code packages
- **API Documentation**: Reading and using library docs
- **Library Installation**: Adding libraries to projects
- **Library Usage**: Importing and calling library functions

### 3.15 Random Values
- **Random Number Generation**: Creating random values
- **Seeding**: Controlling randomness
- **Range Selection**: Getting random values in specific ranges
- **Applications**: Games, simulations, encryption
- **Pseudorandom vs. True Random**: Understanding limitations

### 3.16 Simulations
- **Simulation Definition**: Modeling real-world systems
- **Monte Carlo Methods**: Using randomness in simulations
- **Simulation Design**: Creating effective models
- **Data Collection**: Gathering simulation results
- **Analysis**: Interpreting simulation outcomes

### 3.17 Algorithm Efficiency
- **Time Complexity**: How runtime grows with input size
- **Space Complexity**: How memory usage grows with input size
- **Big O Notation**: O(1), O(log n), O(n), O(nÂ²), etc.
- **Algorithm Comparison**: Choosing efficient algorithms
- **Optimization Techniques**: Improving algorithm efficiency

### 3.18 Undecidable Problems
- **The Halting Problem**: Undecidability example
- **Limitations of Computing**: What computers cannot solve
- **Computational Complexity**: P, NP, NP-complete problems
- **Heuristics**: Approximation solutions
- **Practical Implications**: Real-world undecidable problems
